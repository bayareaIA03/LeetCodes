NOTE = There are two ways that are written in here in making it. 
1. less time / more space -> n / n
2. more time / less space -> nlogm / 1


Given two sorted arrays arr1 and arr2 of passport numbers, implement a function findDuplicates that returns an array of all passport numbers that are both in arr1 and arr2. Note that the output array should be sorted in an ascending order.

Let N and M be the lengths of arr1 and arr2, respectively. Solve for two cases and analyze the time & space complexities of your solutions: M ≈ N - the array lengths are approximately the same M ≫ N - arr2 is much bigger than arr1.

Example:

input:  arr1 = [1, 2, 3, 5, 6, 7], arr2 = [3, 6, 7, 8, 20]

output: [3, 6, 7] # since only these three values are both in arr1 and arr2
Constraints:

[time limit] 5000ms

[input] array.integer arr1

1 ≤ arr1.length ≤ 100
[input] array.integer arr2

1 ≤ arr2.length ≤ 100
[output] array.integer

Answer 1

TIME COMPLEXITY = nlog(m)
SPACE COMPLEXITY = 1
import java.io.*;
import java.util.*;

class Solution {

  static int[] findDuplicates(int[] arr1, int[] arr2) {
    // your code goes here
    //int min = Math.min(arr1.length,arr2.length);
    ArrayList<Integer> list = new ArrayList<>();
    for(int i =0;i<arr1.length;i++){
      int a = bst(arr1,arr2,arr1[i]);
      if(a!=0){
        list.add(a);
      }
    }
    int[] res = new int[list.size()];
    for(int j = 0;j<list.size();j++){
      res[j]=list.get(j);
    }
    return res;
  }
  public static int bst(int[]arr1,int[] arr2,int value){
    int left = 0;
    int right = arr2.length-1;
    while(left<=right){
      int mid = left + (right - left )/2;
      if(arr2[mid] == value){
        return value;
      }
      else if(arr2[mid]<value){
        left=mid+1;
      }
      else{
        right =mid-1;
      }
    }
    return 0;
  }

  public static void main(String[] args) {

  }

}

Answer 2

public class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set = new HashSet<>();
        Set<Integer> intersect = new HashSet<>();
        for (int i = 0; i < nums1.length; i++) {
            set.add(nums1[i]);
        }
        for (int i = 0; i < nums2.length; i++) {
            if (set.contains(nums2[i])) {
                intersect.add(nums2[i]);
            }
        }
        int[] result = new int[intersect.size()];
        int i = 0;
        for (Integer num : intersect) {
            result[i++] = num;
        }
        return result;
    }
}
