Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.

 

Example 1:


Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
Example 2:

Input: preorder = [-1], inorder = [-1]
Output: [-1]


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 
 
 
 

// Needed: preStart to find the beginning of preorder.
//         inStart to find beginnging of inorder
//         inEnd the end of inorder
     //    inIndex = the exact int in the inorder
// Note= 
//     to find root = PREORDER (first node) NOTE = put this in a new node
//                    = INORDER (the node you found preorder + 1)  NOTE=  to find this make a for loop

//    to find left subtree = PREORDER (root node +1);
//                         INORDER (inIndex -1) left side of root of inorder is left subtree
                    
//    to find right subtree = PREORDER (preStart + inIndex - inStart + 1 )
//                         =INORDER (inIndex + 1 till inEnd)

class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {

        return helperBT(0,0,inorder.length-1,preorder,inorder);
    }
    
    public TreeNode helperBT(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder){
        if(inStart > inEnd || preStart > preorder.length-1){
            return null;
        }
        TreeNode newnode = new TreeNode(preorder[preStart]);
        
        int inIndex = 0;
        for(int i =inStart;i<=inEnd; i++){
            if(newnode.val == inorder[i]){
                inIndex = i;
            }
        }
        
        newnode.left = helperBT(preStart + 1,inStart,inIndex-1,preorder,inorder);
        newnode.right = helperBT(preStart + inIndex - inStart + 1,inIndex + 1,inEnd,preorder,inorder);
        
        // (inIndex - inStart + 1) = to get to the left subtree of preorder you would need to subtract the left side of the inorder subtree
        //     and + 1 which will lead to 2nd index which would be the root of the right subtree of the preorder 
        
        // preStart + (inIndex - inStart + 1) = means from where the preorder start + to the right subtree of inorder
        
        return newnode;
    }
}
